# 边缘和线特征检测

---

# 一、边缘检测

> 识别出一系列**边缘点**

## 1.1 基本概念

学习**SIFT**时也遇到过了。再介绍一下这几个概念：

1. 图像梯度
2. 边缘强度
3. 边缘方向
4. 边缘法向量

<details>
<summary>计算公式</summary>

![image_edges](pngs/image_edges.png)

</details>

## 1.2 Canny边缘检测

### 1.2.1 预备知识

1. 这三者是等价的
    1. 先求图像梯度，再滤波
    2. 先滤波，再求图像梯度
    3. 先求滤波器的梯度，再滤波
    - 公式表示如下：
    $$
    \frac {df} {dx} * g = \frac d {dx} (f*g) = f * \frac {dg} {dx}
    $$
2. 二维高斯分布，等价于两个一维高斯分布的乘积
    $$
    G_2(x,y) = G_1(x)G_1(y)
    $$
3. 求图像梯度，往往先用高斯滤波器做平滑，再求导

    - 可以用这个`公式`来加速计算：
        $$
        \nabla (f(x,y) * G_2(x,y)) =
            \begin{bmatrix}
            f(x,y) * G_1'(x) * G_1(y) \\
            f(x,y) * G_1(x) * G_1'(y) \\
            \end{bmatrix}
        \qquad (1)
        $$

        <details>
        <summary>详细推导</summary>

        $$
        \begin{aligned}
        \nabla (f(x,y) * G_2(x,y))
        &=  \begin{bmatrix}
            \frac {\partial [f(x,y) * G_2(x,y)]} {\partial x} \\
            \frac {\partial [f(x,y) * G_2(x,y)]} {\partial y} \\
            \end{bmatrix} & 先滤波，再求导 \\
        \\
        &=  \begin{bmatrix}
            f(x,y) * \frac {\partial G_2(x,y)} {\partial x} \\
            f(x,y) * \frac {\partial G_2(x,y)} {\partial y} \\
            \end{bmatrix} & 先对滤波器求导，再滤波 \\
        \\
        &=  \begin{bmatrix}
            f(x,y) * \frac {\partial G_1(x)G_1(y)} {\partial x} \\
            f(x,y) * \frac {\partial G_1(x)G_1(y)} {\partial y} \\
            \end{bmatrix} & 拆分为两个一维高斯 \\
        \\
        &=  \begin{bmatrix}
            f(x,y) * \left[ \frac {\partial G_1(x)} {\partial x} G_1(y) \right] \\
            \\
            f(x,y) * \left[ G_1(x) \frac {\partial G_1(y)} {\partial y} \right] \\
            \end{bmatrix} \\
        \\
        &=  \begin{bmatrix}
            f(x,y) * \left[ G_1'(x) G_1(y) \right] \\
            f(x,y) * \left[ G_1(x) G_1'(y) \right] \\
            \end{bmatrix} \\
        \\
        &=  \begin{bmatrix}
            f(x,y) * G_1'(x) * G_1(y) \\
            f(x,y) * G_1(x) * G_1'(y) \\
            \end{bmatrix} & 二维滤波，拆分为两个一维滤波 \\
        \\
        \end{aligned}
        $$

        </details> 

### 1.2.2 检测流程

1. 用“**高斯导数滤波器**”，即$G'(x)$，对图像滤波
    - 回顾下上面的`公式`(1)：本质上，这步是先用高斯滤波对图像做平滑，然后求$I_x，I_y$
2. 计算**边缘强度**、**边缘方向**
3. **非极大值抑制**
    - 只保留局部极大值，“细化”边缘
4. 滞后阈值
    - 双阈值法，设置两个阈值$\tau_{low}、\tau_{high}$。识别和连接真正的边缘
    1. **边缘强度**$\ge \tau_{high}$，那么该像素点为边缘点
    2. **边缘强度**$\le \tau_{low}$，那么该像素点不是边缘点
    3. **边缘强度**$\in (\tau_{low}, \tau_{high})$，那么观察它的邻居们（周围8个点）
        - 如果某个邻居的**边缘强度**$\ge \tau_{high}$，那么该像素点也为边缘点

---

# 二、线特征检测

> 经过**边缘检测**，获得了一系列**边缘点**。那么如何确定哪些**边缘点**在一条线上呢？

## 2.1 RANSAC

> 略

## 2.2 霍夫变换

### 2.2.1 基本思想

将图像空间中的线转换到参数空间进行投票

### 2.2.2 直角坐标系中

<details>
<summary>1. 图像中的一条直线，对应霍夫空间的一个点</summary>

![hough_transform_1](pngs/hough_transform_1.png)

</details>

<details>
<summary>2. 图像中的一个点，对应霍夫空间的一条线</summary>

![hough_transform_2](pngs/hough_transform_2.png)

</details>

<details>
<summary>3. 将霍夫空间离散化（画出网格）。然后画出图像中的每个点，对应到霍夫空间的直线</summary>

![hough_transform_3](pngs/hough_transform_3.png)

</details>

<details>
<summary>4. 累积投票。票数最多的网格（转换成点），即可对应出图像中的一条直线</summary>

![hough_transform_4](pngs/hough_transform_4.png)

</details>

### 2.2.3 极坐标系中

#### 直角坐标系中存在的问题：
- 图像中的一条直线，y=mx+b。
- m、b的取值范围都是无穷大，霍夫空间中的网格就画不完...

#### 解决思路
- 转换到极坐标系：
    - 与直角坐标系中类似：
    1. 图像中的一条直线，对应霍夫空间的一个点
    2. 图像中的一个点，对应霍夫空间中的一条曲线
    3. 然后画出图像中的每个点，对应到霍夫空间的曲线，累积投票

#### 伪代码

![hough_transform_code](pngs/hough_transform_code.png)
> $\theta \in [0,180]$，范围是有限的。  
> 图像空间中的每个点，我们可以遍历$\theta$，利用该公式计算出对应的$\rho$：
> $$
> \rho = x \cos \theta + y \sin \theta
> $$
> 然后再去累积投票

### 2.2.4 如何选择`bucket size`?

1. `bucket size`太小，试想整个霍夫空间中画满了网格。
    - 最后累积投票，每个网格1票...
2. `bucket size`太大，例如整个霍夫空间划分成4个网格
    - 显然最后拟合效果很差

- 解决办法：
    1. 先用大一些的`bucket size`去检测
    2. 再用最小二乘法，对直线做校正